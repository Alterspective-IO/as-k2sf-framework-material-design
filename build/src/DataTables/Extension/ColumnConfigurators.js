import { TargetType } from "../../Common/commonSettings";
import { AS_K2_DataTable_Default_Column_Settings, AS_K2_DataTable_Default_Settings, AS_OptGrid_Header_Column_Info_Default } from "./defaults";
import { applyK2FormatToFormatter, applyK2StyleToRenderer } from "./StyleRenderers";
import { applySettingsToObject } from "../../Common/ObjectHelpers";
import { ListViewInstance } from "asFramework/src/index";
/**
 * configure the grid columns with autogenerated columns and any specified columns
 * @param newDataTable - the data table to configure
 * @param target
 * @returns
 */
export function configureColumns(passPack, settings) {
    //newDataTable: AsMaterialdesignDatatableExtended,
    var _a, _b, _c;
    let retValue = {
        columns: [],
        headers: []
    };
    if (!passPack)
        return retValue;
    if (!settings) {
        settings = new AS_K2_DataTable_Default_Settings();
    }
    //set return values to that of the passed in target settings
    retValue.columns = ((_a = settings.optGrid) === null || _a === void 0 ? void 0 : _a.columns) || [];
    retValue.headers = ((_c = (_b = settings.optGrid) === null || _b === void 0 ? void 0 : _b.header) === null || _c === void 0 ? void 0 : _c.columns) || [];
    if (passPack.target.type == TargetType.controls) {
        //Check if we need to autogenerate columns, but only for controls
        retValue.columns = configureColumnsForControl(passPack, retValue.columns);
    } //if a view then created based on the existing list view settings
    else {
        let pair = configureColumnsForView(passPack, settings, retValue.columns, retValue.headers);
        retValue.columns = pair.columns;
        retValue.headers = pair.headers;
    }
    //Ensure the column defaults are applied to existing columns 
    applyDefaultsToColumns(retValue.columns, passPack);
    return retValue;
}
function configureColumnsForView(passPack, settings, gridColumns, gridHeaders) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    if (passPack.processedSettings.autoGenerateColumns != true) {
        return { columns: gridColumns, headers: gridHeaders };
    }
    let retValueColumns = new Array();
    let retValueHeaders = new Array();
    let vi = passPack.target.referencedK2Object;
    let lvi = vi.as(ListViewInstance);
    let fields = vi.rawData.fields.field;
    let listViewColumns = lvi.getColumnControls();
    let systemDefaults = new AS_K2_DataTable_Default_Settings();
    //set the absolute minimum column width, look in passed in settings, then system defaults and then 50
    let minWidthOfColumn = ((_a = settings.columnDefaults) === null || _a === void 0 ? void 0 : _a.minWidth) || ((_c = (_b = settings.optGrid) === null || _b === void 0 ? void 0 : _b.columnOptions) === null || _c === void 0 ? void 0 : _c.minWidth) || systemDefaults.columnDefaults.minWidth || ((_d = systemDefaults.optGrid.columnOptions) === null || _d === void 0 ? void 0 : _d.minWidth) || 50;
    for (let colsIndex = 0; colsIndex < listViewColumns.length; colsIndex++) {
        const listViewColumn = listViewColumns[colsIndex];
        if (!((_e = listViewColumn.header) === null || _e === void 0 ? void 0 : _e.value))
            continue; //if not header then skip
        //Add processing info from K2 for users to debug
        let extraInfo = {}; //place to store processing info for developer to see what happened
        let processingIssues = {}; //add any processing issue here
        //Get the K2 field ( data field ) that this header is relagted to
        let field = fields.find((f) => { var _a; return f.id == ((_a = listViewColumn.header) === null || _a === void 0 ? void 0 : _a.fieldId); });
        let systemName = (field === null || field === void 0 ? void 0 : field.propertyName) || ((_f = listViewColumn.header) === null || _f === void 0 ? void 0 : _f.value) || "";
        let colName = ((_h = (_g = listViewColumn.display) === null || _g === void 0 ? void 0 : _g.field) === null || _h === void 0 ? void 0 : _h.name) || ((_j = listViewColumn.header) === null || _j === void 0 ? void 0 : _j.value);
        //let newColumnName = listViewColumn.header.value
        //Setup objects and add to Array Results
        let newColSettings = createNewColumnWithSystemAndUserDefaults(passPack, colName);
        newColSettings.name = colName;
        let newColHeaderSettings = createNewColumnHeaderWithSystemAndUserDefaults(passPack, colName);
        newColHeaderSettings.name = colName;
        retValueColumns.push(newColSettings);
        retValueHeaders.push(newColHeaderSettings);
        let existingColConfig = gridColumns.find(gc => gc.name == colName);
        if (existingColConfig) {
            continue;
            //applySettingsToObject(newColSettings,existingColConfig,"settings")
        }
        newColSettings.header = (_k = listViewColumn.header) === null || _k === void 0 ? void 0 : _k.value;
        newColSettings.extraInfo = extraInfo;
        //Get the K2 Grid TD element for the column to get styling settings not found in data objects
        let columnTableDivisionElement = (_l = listViewColumn.header) === null || _l === void 0 ? void 0 : _l.getHTMLElement().parentElement.parentElement.parentElement.parentElement;
        //Check if the column is hidden
        let parentDisplay = getComputedStyle(columnTableDivisionElement).display;
        if (parentDisplay == "none") {
            newColSettings.hidden = true;
        }
        //get the currnet K2 column width and apply
        try {
            let computedWidth = Number.parseFloat(getComputedStyle(columnTableDivisionElement).width);
            if (!isNaN(computedWidth)) {
                newColSettings.minWidth = computedWidth;
                if (newColSettings.minWidth < minWidthOfColumn)
                    newColSettings.minWidth = minWidthOfColumn;
            }
        }
        catch (ex) {
            processingIssues[`Failed to set grid list [${passPack.target.referencedK2Object.name}] header [${newColSettings.header}] width `] = ex;
        }
        //get the styles fom the different K2 controls
        let headerCellStyle = (_q = (_p = (_o = (_m = listViewColumn.header) === null || _m === void 0 ? void 0 : _m.rawData) === null || _o === void 0 ? void 0 : _o.properties) === null || _p === void 0 ? void 0 : _p.styles) === null || _q === void 0 ? void 0 : _q.style;
        let displayCellStyle = (_r = listViewColumn.display) === null || _r === void 0 ? void 0 : _r.rawData.properties.styles.style; //.font.color
        let colCellStyle = (_u = (_t = (_s = listViewColumn.column) === null || _s === void 0 ? void 0 : _s.rawData.properties) === null || _t === void 0 ? void 0 : _t.styles) === null || _u === void 0 ? void 0 : _u.style;
        extraInfo.k2HeaderCellStyle = headerCellStyle;
        extraInfo.k2DisplayCellStyle = displayCellStyle;
        extraInfo.k2ColStyle = colCellStyle;
        // extraInfo.listViewColumn = listViewColumn //cannot add object with recursive references in
        //Set the ALIGN properties - Note - align is not set in styles renderer or fomatter
        //match col styles first then override with header and display if required
        if ((_v = colCellStyle === null || colCellStyle === void 0 ? void 0 : colCellStyle.text) === null || _v === void 0 ? void 0 : _v.align) {
            newColSettings.align = colCellStyle.text.align.toLowerCase();
        }
        //style Headers
        if ((_w = headerCellStyle === null || headerCellStyle === void 0 ? void 0 : headerCellStyle.text) === null || _w === void 0 ? void 0 : _w.align) {
            newColHeaderSettings.align = headerCellStyle.text.align.toLowerCase();
        }
        //style display items
        if ((_x = displayCellStyle === null || displayCellStyle === void 0 ? void 0 : displayCellStyle.text) === null || _x === void 0 ? void 0 : _x.align) {
            newColSettings.align = displayCellStyle.text.align.toLowerCase();
        }
        newColSettings.renderer = applyK2StyleToRenderer(displayCellStyle, newColSettings.renderer);
        newColSettings.formatter = applyK2FormatToFormatter(displayCellStyle, newColSettings.formatter, systemName, (_y = listViewColumn.display) === null || _y === void 0 ? void 0 : _y.dataType);
    }
    return { columns: retValueColumns, headers: retValueHeaders };
}
function createNewColumnHeaderWithSystemAndUserDefaults(passPack, name) {
    var _a, _b, _c;
    let settings = passPack.processedSettings;
    //create with system defaults
    let retValue = new AS_OptGrid_Header_Column_Info_Default();
    retValue.name = name;
    //update with user specific defaults
    applySettingsToObject(retValue, (_c = (_b = (_a = settings.optGrid) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.columns) === null || _c === void 0 ? void 0 : _c.find(h => h.name == name));
    return retValue;
}
function configureColumnsForControl(passPack, gridColumns) {
    if (passPack.processedSettings.autoGenerateColumns == true) {
        let autoGeneratedColumns = autoGenerateColumns(passPack, passPack.target.referencedK2Object.smartobject.items);
        if (autoGeneratedColumns)
            gridColumns = gridColumns.concat(autoGeneratedColumns);
    }
    return gridColumns;
}
export function applyDefaultsToColumns(gridColumns, passPack) {
    for (let index = 0; index < gridColumns.length; index++) {
        const column = gridColumns[index];
        //set the current column to new column with all defaults applied including its own specific settings
        gridColumns[index] = createNewColumnWithSystemAndUserDefaults(passPack, column.name, column);
    }
}
/**
* Autogenerate columns based on a data object
* @param passPack
* @param data
* @returns
*/
export function autoGenerateColumns(passPack, data) {
    var _a;
    let retValue = [];
    if (!data)
        return retValue;
    //setup column defaults from default settings and any column configuration passed in the settings
    let colDefaults = createNewColumnWithSystemAndUserDefaults(passPack, undefined);
    //try autogenerate based on data we have
    if (data) {
        if (data[0]) {
            for (const property in data[0]) {
                let existingCol = (_a = passPack.processedSettings.optGrid) === null || _a === void 0 ? void 0 : _a.columns.find((column) => column.name == property);
                if (!existingCol) {
                    //only autogenerate if we dont already have one specified
                    let newCol = {
                        name: property,
                    };
                    applySettingsToObject(newCol, colDefaults, "primary");
                    //Add header and convert to propper case
                    newCol.header = property;
                    if (newCol.header.length > 3) {
                        const result = property.replace(/([A-Z])/g, " $1");
                        newCol.header = result.charAt(0).toUpperCase() + result.slice(1);
                    }
                    retValue.push(newCol);
                }
            }
        }
    }
    return retValue;
}
export function createNewColumnWithSystemAndUserDefaults(passPack, name, existing) {
    var _a, _b;
    let priorityTo = "settings";
    if (existing)
        priorityTo = "primary";
    let colDefaults = existing || {
        name: name || "notSet"
    };
    //apply system defaults
    applySettingsToObject(colDefaults, new AS_K2_DataTable_Default_Column_Settings, "primary");
    //apply user defined defaults 
    applySettingsToObject(colDefaults, passPack.processedSettings.columnDefaults, priorityTo);
    if (name) {
        let foundColumn = (_b = (_a = passPack.processedSettings.optGrid) === null || _a === void 0 ? void 0 : _a.columns) === null || _b === void 0 ? void 0 : _b.find(c => c.name == name);
        //apply specific user defined column settings with top priotity
        applySettingsToObject(colDefaults, foundColumn, priorityTo);
        colDefaults.name = name;
    }
    return colDefaults;
}
//# sourceMappingURL=ColumnConfigurators.js.map