import { executeControl, attachHandler } from "./control-helpers";
import { IControllerDefinition } from "../interfaces/AGIControllerDefinition";
import { ControlType, ContainerType } from "../interfaces/enums";
import { IAttachedCustomControl } from "../interfaces/IAttachedCustomControl";
import { IContainer } from "../interfaces/IContainer";
import { IContentControl } from "../interfaces/IContentControl";
import { IControlEvent } from "../interfaces/IControlEvent";
import { IControlEvents } from "../interfaces/IControlEvents";
import { IControlProperties } from "../interfaces/IControlProperties";
import { ControlRuleKeys, IControlRules } from "../interfaces/IControlRules";
import { IControls } from "../interfaces/IControls";
import { IEmittedControlEvent } from "../interfaces/IEmittedControlEvent";
import { INameValueAny } from "../interfaces/INameValue";
import { IFieldInfo, ISmartObject } from "../interfaces/SmartObjects/ISmartObject";
import { IStyleElement } from "../interfaces/IStyleElement";
import { autoMapAttributesToProperties } from "../processors";
import { BaseArray, BaseItem } from "./base";
import { ControlProperties } from "./properties";
import { implementControlExtensions } from "./html-helpers";
import { IField } from "../interfaces/IField";
import { IViewInstance } from "../interfaces/IViewInstance";
import { IControl } from "../interfaces/IControl";
import { k2FieldTypeToJavascriptType } from "./Helpers/TypeConverter";
import { Type } from "../interfaces/AutoGenerated/so-controller";
import { getControlSmartobject } from "./smartObject";
import { ChangedPropertyEvent, EventTimingOption } from "../interfaces/IEvents";





export class Controls extends BaseArray<Control, IControllerDefinition.Control, IContainer> implements IControls {
    constructor(control: IControllerDefinition.Control[] | undefined, parent: IContainer) {
        //let p = new PerformanceSession("Controls.Constructor()")
        super(Control, control, parent);
        //p.finish()
    }
}



export class Control extends BaseItem<IControllerDefinition.Control, IContainer> implements IControl {
    
    constructor(control?: IControllerDefinition.Control, parent?: IContainer)
    constructor(control: IControllerDefinition.Control, parent: IContainer) {
        // let p = new PerformanceSession("Control.Constructor()")
        super(control!, parent!)

        this.controlTemplate = undefined
        this.dataType = undefined
        this.expressionId = undefined
        this.fieldId = undefined
        this.panelId = undefined
        this.type = ControlType.NotSet
        this.styles = {}
        this.events = new ControlEvents(this)
        this._rules 
        

        if(!control) return;

        autoMapAttributesToProperties(control, this)
     
        this.containerType = ContainerType.control

        //TODO:
        this.properties = new ControlProperties(control!.properties, this)
        this.id = control!.id

        this.extensions = new ControlExtensions()
        implementControlExtensions(this)

        //add this control to all controls
        this._as!.collections?.viewInstanceControls?.push(this)

        this.eventTarget.dispatchEvent(new CustomEvent("initialized",{detail:this}))

        
        //  p.finish()

    }
    private eventTarget = new EventTarget()
    private readonly targetType = 'changed';
    styles: IStyleElement;
    type: ControlType;
    properties?: IControlProperties;
    // override id? :string;
    dataType: IControllerDefinition.Type | undefined;
    panelId: string | undefined;
    fieldId: string | undefined;
    expressionId?: string | undefined;
    controlTemplate?: IControllerDefinition.ControlTemplate | undefined;
    // newV:string = "FFFF"
    attachedEvents = new Array<EmittedControlEvent>()
    events: IControlEvents
    attachedCustomControl?:IAttachedCustomControl
    extensions?: ControlExtensions
 



    addPropertyListener(type:string,timing: EventTimingOption,callback: (evt: CustomEvent<ChangedPropertyEvent>) => void): void 
    {
        return this.eventTarget.addEventListener(type+timing, callback as (evt: Event) => void);
    }
    dispatchPropertyEvent(type:string,timing: EventTimingOption,event: ChangedPropertyEvent): boolean 
    {
        return this.eventTarget.dispatchEvent(new CustomEvent(type+timing, { detail: event }));
    }
    removePropertyListener(type:string,timing: EventTimingOption,callback: (evt: CustomEvent<ChangedPropertyEvent>) => void): void
    {
        return this.eventTarget.removeEventListener(type+timing, callback as (evt: Event) => void);
    }

    
    // //You attached to control rules events not to controls
    // public addListener(smartFormEventTypes:string, callback: (evt: CustomEvent<ChangedEvent>) => void): void {
    //   //  console.log(`---> TCL: Control -> addListner -> event [${smartFormEventTypes}] `)        
    //     return this.eventTarget.addEventListener(smartFormEventTypes, callback as (evt: Event) => void);
    //   }
    
    // public dispatch(smartFormEventTypes: string ,event: ChangedEvent): boolean {    
    //    // console.log(`---> TCL: Control -> dispatch -> event [${smartFormEventTypes}] :`, event)          
     
    //     return this.eventTarget.dispatchEvent(new CustomEvent(smartFormEventTypes, { detail: event }));
    //   }
    
    //  public removeListener(smartFormEventTypes:string,callback: (evt: CustomEvent<ChangedEvent>) => void): void {
    //     return this.eventTarget.removeEventListener(smartFormEventTypes, callback as (evt: Event) => void);
    //   }

    //on demand
    private _rules: IControlRules | undefined
    private _rulesInitialized: boolean = false
    public get rules(): IControlRules {
        if (!this._rules) {
            this._rules = {}
            let controlRules = this._as!.collections.rules?.rules?.filter(r => r.sourceId == this.id) || []
            controlRules.forEach(r => {               
                this._rules![r.name as ControlRuleKeys] = r                                
            })
            this._rulesInitialized = true;

        }
        return this._rules
    }


    public get value(): string | undefined {
        if(this.type==ControlType.Label)
            return this.getControlPropertyValue("Text")
        return executeControl(this, "GetValue",this._as);        
    }

    public set value(value: string | undefined) {       
        executeControl(this, "SetValue",this._as, value);
    }

    private _field : IField | null = null
 public get field() : IField | null {

    if(this._field) return this._field;
    if(!this.fieldId){
        return this._field;
    }

    try
    {
        let x = document.evaluate(`//Field[@ID='${this.fieldId!}' and @ContextID='${(this.parent as IViewInstance).contextId!}']`,
        this._as.supportingObjects.__runtimeControllersDefinition_Document!,null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0)
        if(x)
        {
            this._field = this._as.convertXMLtoJSON(x).field
        }
    }
    catch
    {}

    return this._field
 }


    execute(method: string, optionalPropertyName: string, optionalValue: string) {
        executeControl(this, method,this._as, optionalValue, optionalPropertyName);       
    }

    getControlPropertyValue(propertyName: string) {
        let propValue 
        if(!propertyName) return undefined
        if(propertyName.length==0) return undefined
        // var functionName = "GetProperty";
        // return executeControl(this, functionName, this._as,null, propertyName);
        //return this.properties?.find(p=>p.name==propertyName)?.value

        //first use executecontrol for props that can dynamically change
        if(this.type!=ControlType.Label)
        {
            propValue = executeControl(this, "GetProperty",this._as, undefined,propertyName);
        }
        //if non come back try find in the static properties
        if(typeof propValue=="undefined" || propValue == null)
        {
            propValue = this.properties?.find(p=>p.name.toLocaleLowerCase()==propertyName.toLocaleLowerCase())?.value
        }

        return propValue
    }

    setControlPropertyValue(propertyName: string, propertyValue: string) {
        return executeControl(this, "SetProperty", this._as,propertyValue, propertyName);
    }

    getPropertyValue(property: string) {
        return this.getControlPropertyValue(property);
    };

    setPropertyValue(property: string, value: any) {
        this.setControlPropertyValue(property, value);
    };

    setControlVisibility(IsVisible: boolean) {

        if(this.type==ControlType.Cell)
        {
            if(IsVisible)
                this.getHTMLElement().style.display="";
                else
                this.getHTMLElement().style.display="none";
        }
        else
        {
            this.setControlPropertyValue("IsVisible", `${IsVisible}`);
        }
    };

    get smartobject() : ISmartObject 
    {
        return getControlSmartobject(this)
      };


    asContentControl() : IContentControl
    {
        let retValue = new ContentControl();
        Object.assign(retValue,this)
        return retValue;
    }

}

export class ContentControl extends Control implements IContentControl
{
    private _autoResize : boolean = false

    constructor(){
        super()
    }

    iframeResizedCallback = (e:iframeResizer.IFrameResizedData) =>
    {
        let parentDiv = this.getHTMLElement()
        $(parentDiv).height(e.height)
        console.log(e)
    }

    public showSomething(something: string) : string
    {
        return something + "_______"
    }

    public set autoResize(value: boolean) {
        console.log("ðŸš€ ~ file: control.ts ~ line 195 ~ setautoResize ~ value", value)
        this._autoResize = value;
        if(value==true)
        {
            let containedIframe = this.containedIFrame;
            this._as!.iFrameResizer({ log: false, heightCalculationMethod:"documentElementOffset" , checkOrigin: false, resizedCallback:this.iframeResizedCallback }, containedIframe);
        }
    }

    get containedIFrame() {
        let parentDiv = this.getHTMLElement();
        let containedIframe = $("iframe", parentDiv)[0] as HTMLIFrameElement;
        return containedIframe;
    }

    public get autoResize() : boolean {
        return this._autoResize;
    }


}

export class EmittedControlEvent {

    control: Control
    eventName: string
    controlEvent: string
    controlEventState: string | null
    type: string
    functionToExecute: Function
    enabled: boolean
    additional?: any
    id?: string
    deleted: boolean

    constructor(
        control: Control,
        name: string,
        event: string,
        state: string | null,
        type: string,
        func: Function,
        enabled: boolean,
        additional?: any,
        optionalId?: string
    ) {

        this.control = control;
        this.controlEvent = event;
        this.functionToExecute = func;
        this.controlEventState = state;
        this.eventName = name;
        this.type = type;
        this.enabled = enabled;
        this.additional = additional;
        this.id = optionalId; //generate ID for this event.
        this.deleted = false
    }


    remove() {
        console.log(this);
        this.deleted = true;
        if (this.type === "jquery") {
            // $(this.this.HTMLElement()).unbind(this.controlEvent);
            //Dont need to remove as even checking will make sure disabled donet fire as well as make sure we dont add more events to native event hander than we need
        } else {
            //
        }
    };
}
export class ControlEvent implements IControlEvent {


    constructor(public name: string,
        public controlEvent: string,
        public controlEventState: string,
        public type: string,
        public applyTo: string,
        public parentControl: Control
    ) { }

    removeEvent(event: any) : void {
        event.remove();
    };

    addEvent(
        func: Function,
        optionalAdditional?: any,
        optionalId?: string
    ) : IEmittedControlEvent {


        let newControlEvent = new EmittedControlEvent(
            this.parentControl,
            this.name,
            this.controlEvent,
            this.controlEventState,
            this.type,
            func,
            true,
            optionalAdditional,
            optionalId
        );

        if (
            this.parentControl.attachedEvents.filter(function (e) {
                return e.eventName == newControlEvent.eventName;
            }).length == 0
        ) {
            if (this.type === "smartform") {
                attachHandler(
                    this.parentControl,
                    this.controlEvent,
                    this.controlEventState,
                    (controlInfo: any, valueInfo: any, value: any) => {
                        this.parentControl.attachedEvents.filter((ctrEvent: any) => {
                            return (
                                ctrEvent.controlEvent === this.controlEvent &&
                                ctrEvent.controlEventState ===
                                this.controlEventState &&
                                ctrEvent.type === "smartform"
                            );
                        }).forEach(function (ctrEvent) {
                            if (typeof ctrEvent.functionToExecute === "function") {
                                if (ctrEvent.deleted == false)
                                    if (ctrEvent.enabled == true) {
                                        ctrEvent.functionToExecute(ctrEvent);
                                    }
                            }
                        });
                    }
                );
            }

            if (this.type === "jquery") {
                ($(this.parentControl.getHTMLElement()) as any)[this.controlEvent]((
                    jqueryEvent: any
                ) => {
                    if (this.parentControl.attachedEvents != null) {
                        this.parentControl.attachedEvents.filter((ctrEvent) => {
                            var f = ctrEvent;
                            return (
                                ctrEvent.controlEvent === this.controlEvent &&
                                ctrEvent.type === "jquery"
                            );
                        }).forEach(function (ctrEvent) {
                            if (typeof ctrEvent.functionToExecute === "function") {
                                try {
                                    if (ctrEvent.deleted == false)
                                        if (ctrEvent.enabled == true)
                                            ctrEvent.functionToExecute(ctrEvent, jqueryEvent);
                                } catch (err: any) {
                                    console.warn(
                                        "Error in attached event function: " + err.message
                                    );
                                }
                            }
                        });
                    }
                });
            }
        }


        if(!optionalId)
        {
            optionalId = `__${this.parentControl.attachedEvents.length}`
        }

        let existingEvent :EmittedControlEvent | undefined
        
        if(this.parentControl.attachedEvents)
        {
            existingEvent= this.parentControl.attachedEvents.find(e=>e.id==optionalId)
        }

        if(existingEvent)        
        {
            console.log("TCL: ControlEvent -> existingEvent", existingEvent)
            existingEvent = newControlEvent
        }
        else
        {
            this.parentControl.attachedEvents.push(newControlEvent);
        }
        return newControlEvent;
    };

}
export class ControlExtensions {
    [name: string]: any
    properties: Array<string> = [];

    constructor() {
    }

    addExtension(nameValue: INameValueAny) {
        this[nameValue.name] = nameValue.value
        this.properties.push(nameValue.name)
    }

}

class ControlEvents implements IControlEvents {

    parentControl: Control
    elementKeypress: ControlEvent;

    constructor(parentControl: Control) {
        this.parentControl = parentControl;
    

    this.smartformEventChanged = new ControlEvent("smartformEventChanged",
        "OnChange",
        "after",
        "smartform",
        "", this.parentControl)

    // smartformEventPopulated = new ControlEvent("smartformEventPopulated",
    //     "OnSetItemsCompleted",
    //     "before",
    //     "smartform",
    //     "",
    //     this.parentControl)

        this.smartformEventPopulated = new ControlEvent("smartformEventPopulated",
        "SetItems",
        "before",
        "smartform",
        "",
        this.parentControl)

        this.smartformEventClicked = new ControlEvent("smartFormEventClicked",
        "OnClick",
        "after",
        "smartform",
        "", this.parentControl)

        this.smartFormEventClick = new ControlEvent("smartformEventClick",
        "OnClick",
        "before",
        "smartform",
        "", this.parentControl)
        this.elementClick = new ControlEvent("elementClick",
        "click",
        '',
        "jquery",
        "", this.parentControl)
        this.elementMouseMove = new ControlEvent("elementMouseMove",
        "mousemove",
        '',
        "jquery",
        "", this.parentControl)
        this.elementMouseEnter = new ControlEvent("elementMouseEnter",
        "mouseenter",
        '',
        "jquery",
        "", this.parentControl)
        this.elementMouseLeave = new ControlEvent("elementMouseLeave",
        "mouseleave",
        '',
        "jquery",
        "", this.parentControl)
        this.elementHover = new ControlEvent("elementHover",
        "hover",
        '',
        "jquery", "", this.parentControl)

        this.elementLostFocus = new ControlEvent("elementLostFocus",
        "focusout",
        '',
        "jquery", "", this.parentControl)


        this.elementKeypress
        = new ControlEvent("elementKeypress",
        "keypress",
        '',
        "jquery", "", this.parentControl)
    }

smartformEventChanged : ControlEvent
smartformEventPopulated : ControlEvent
smartformEventClicked : ControlEvent
smartFormEventClick : ControlEvent
elementClick : ControlEvent
elementMouseMove : ControlEvent
elementMouseEnter : ControlEvent
elementMouseLeave : ControlEvent
elementHover : ControlEvent
elementLostFocus : ControlEvent
}
