import { Framework } from "./framework";
import { camelCase, xmlToXMLDocument } from "./Helpers/framework.utils";
import * as Definition from "../interfaces/AutoGenerated/so-rulesv2";
import { SourceType } from "../interfaces/AutoGenerated/so-rulesv2";
import * as xmlHelper from "./Helpers/xmlHelper";
import { IFramework } from "../interfaces/IFramework";
import { EventTimingOption } from "../interfaces/IEvents";
import * as _ from "lodash";
import { Log, LogType, PerformanceSession } from "./framework.performance";
import { IViewInstance } from "../interfaces/IViewInstance";
import { IControl } from "../interfaces/IControl";
import { IForm } from "../interfaces/IForm";
import {IContainer} from "../interfaces/IContainer"
import { utils } from "..";

let runtimeEventsDefinitionXMLDocument: XMLDocument;


export enum ActionType {
    ApplyStyle = "ApplyStyle",
    Calculate = "Calculate",
    Execute = "Execute",
    ExecuteControl = "ExecuteControl",
    Exit = "Exit",
    Transfer = "Transfer",
    Validate = "Validate",   
    List = "List",
    Open = "Open",
    Popup = "Popup"  
}
export enum LocationEnum {
    Control = "Control",
    ObjectProperty = "ObjectProperty",
    Result = "Result",
    Value = "Value",
    ViewField = "ViewField",
    ViewParameter = "ViewParameter",
    ItemState = "ItemState",
    SystemVariable = "SystemVariable", 
    Form = "Form",
    Rule = "Rule",
    SourceTypeView = "view",
    View = "View",
}

export const xmlProxyHandler = {
  get: function (target: XMLBase<any>, name: string, receiver: any) {
    if (typeof name == "string" && !name.startsWith("_")) {
      if (!(name in target)) {
        let foundValue = undefined;
        // console.log("Getting non-existant property '" + name + "'");
        // switch (name.toLocaleLowerCase()) {
        //   case "name":
        //     foundValue = target.element.getElementsByTagName("Name")[0].textContent || undefined
        //     break
        //   case "sourcevalue":
        //     foundValue = target.element.textContent;
        //     break;
        //   default:
        //     break;
        // }

        if (!foundValue) {
          foundValue = xmlHelper.getAttributeValue(name, target.element);
        }
        if (foundValue) {
          Reflect.set(target, name, foundValue, receiver);
          return foundValue;
        }
        Reflect.set(target, name, foundValue, receiver);
        return undefined;
      }
    }
    return Reflect.get(target, name, receiver);
  },
  set: function (target: any, name: string, value: any, receiver: any) {
    if (!(name in target)) {
      //   console.log(
      //     // "Setting non-existant property '" + name + "', initial value: " + value
      //   );
    }
    return Reflect.set(target, name, value, receiver);
  },
};

export class XMLBase<Parent> {
  _as: IFramework | undefined;
  element: Element;
  parent: Parent | undefined;

  constructor(element: Element, as?: IFramework, parent?: Parent) {
    this._as = as;
    this.element = element!;
    if (parent) this.parent = parent;
    //return new Proxy(this, xmlProxyHandler);
    this.populateProperties();
  }

  populateProperties() {
    this.element.getAttributeNames().forEach((name) => {
      (this as any)[camelCase(name)] = this.element.getAttribute(name);
    });
  }
}

// export function getAll() {
//   let evs = new Rules(window.__runtimeEventsDefinition, (window as any).as);

//   let option: utils.JP.JSONPathOptions = {
//     path: "$..logic",
//     json: evs,
//   };

//   let items = utils.JP.JSONPath(option);
//   console.log(items);
// }

export class Rules
  extends XMLBase<IForm>
  implements Omit<Definition.Events, "event">
{
  constructor(__runtimeEventsDefinition: string, as: Framework) {
    let p = new PerformanceSession("Populating Events");
    let runtimeEventsDefinitionXMLDocument = xmlToXMLDocument(
      __runtimeEventsDefinition
    )!;
    super(runtimeEventsDefinitionXMLDocument.children[0], as, as.form);
    this.rules = Array.from(this.element.querySelectorAll("Event")).map(
      (el) => {
        return new Rule(el, this._as);
      }
    );
    p.finish();
  }

  public renderWorkflowStrip!: string;
  public hasServerEvent!: string;

  rules: Array<Rule> | undefined;
}

export class Rule
  extends XMLBase<IViewInstance | IForm | IControl>
  implements Omit<Definition.Event, "isReference" | "isInherited" | "handlers">
{
  constructor(xmlEventElement: Element, as?: IFramework) {
    super(xmlEventElement, as);
    this.eventTarget.dispatchEvent(
      new CustomEvent("initialized", { detail: this })
    );

    this.handlers = Array.from(this.element.querySelectorAll("Handler")).map(
      (h) => {
        return new Handler(h, this._as, this);
      }
    );
    this.isFormLevelRule = this.viewId ? true : false;
    this.isUnboundRule = this.sourceType == SourceType.Rule;
    this.setParent();
    this.name =
      this.element.getElementsByTagName("Name")[0].textContent || "Unknown";
  }

  //
  name: string;
  _attachedListeners = new Array<any>()
  //

  sourceId!: string;
  sourceType!: SourceType;
  instanceId?: string | undefined;
  id!: string;
  definitionId!: string;
  type!: Definition.EventType;
  isEnabled!: string;
  ruleFriendlyName?: string | undefined;
  location?: string | undefined;
  viewId?: string | undefined;
  isCustomName?: string | undefined;
  ruleName?: string | undefined;
  subformId?: string | undefined;
  subformInstanceId?: string | undefined;
  formId?: string | undefined;
  ruleDescription?: string | undefined;

  eventTarget = new EventTarget();
  handlers: Array<Handler>;

  private setParent(): void {
    switch (this.sourceType) {
      case SourceType.Control:
        this.parent = this._as?.getControlsById(this.sourceId)[0];
        break;
      case SourceType.Form:
        this.parent = this._as?.form;
        break;
      case SourceType.Rule:
        if (!this.viewId) this.parent = this._as?.form;

        break;
      case SourceType.SourceTypeView:
        console.warn("not implemented yet");
        return undefined;
        break;
      case SourceType.View:
        this.parent = this._as?.collections.viewInstances.find(
          (vi) => vi.instanceId == this.instanceId
        );
        break;
      default:
        break;
    }
  }

  isUnboundRule: boolean;
  isFormLevelRule: boolean;


  execute(): any {
    return window.handleEvent(
      this.sourceId,
      this.sourceType,
      this.name,
      null,
      this.instanceId
    );
  }


  public addListener( id:string,  
    callback: (evt: CustomEvent<Rule>) => void
  ): void {

    console.log(`Attached Listners to ${this._attachedListeners.length} ${this.name}`)
    //make sure we dont have any duplicates
    let foundListener = this._attachedListeners.find(l=>l.id == id)
    if(foundListener)
    {
      this.removeListener(id);
    }
  
    this._attachedListeners.push({id:id,callback:callback})

    return this.eventTarget.addEventListener(
      this.getEventName,
      callback as (evt: any) => void
    );
  }

  get getEventName() : string {
    return this.ruleFriendlyName || this.name
  }

  public dispatch(): boolean {
       let container = this.parent as IContainer
    if(container)
    {
      Log(`${container.containerType} [${container.name}] dispatching event [${this.ruleFriendlyName || this.name}]  `, {logType:LogType.events})
    }    
    let details = this;
    return this.eventTarget.dispatchEvent(new CustomEvent(this.getEventName, { detail: details })
    );
  }

  public removeListener(  id:string
  ): void {

    let foundListener = this._attachedListeners.find(l=>l.id == id)
   
   this.eventTarget.removeEventListener(
      this.getEventName,
      foundListener.callback
    );
    _.remove(this._attachedListeners, l=>l.id == id)
  }
}

export class Handler
  extends XMLBase<Rule>
{
  constructor(element: Element, as?: IFramework, parent?: Rule) {
    super(element, as, parent);
    this.conditions = Array.from(
      this.element.querySelectorAll("Condition")
    ).map((h) => {
      return new Condition(h, this._as, this);
    });

    this.actions = Array.from(
        this.element.querySelectorAll("Action")
      ).map((h) => {
        return new Action(h, this._as, this);
      });
    //TODO Actions
  }

  conditions: Condition[] | undefined;
  actions!: Array<Action>
  type!: Definition.HandlerType;
}

export class Condition
  extends XMLBase<Handler>
  implements Definition.ConditionElement, Definition.PurpleCondition
{
  constructor(element: Element, as?: IFramework, parent?: Handler) {
    super(element, as, parent);
    this.logic = Array.from(this.element.children)
      .filter((e) => e.tagName != "Item")
      .map((el) => {
        return new ConditionLogic(el, this._as, this);
      });
  }
  isReference!: Definition.Is;
  isInherited!: Definition.Is;
  logic: ConditionLogic[] | undefined;
}

export class ConditionLogic extends XMLBase<ConditionLogic | Condition> {
  constructor(
    element: Element,
    as?: IFramework,
    parent?: ConditionLogic | Condition
  ) {
    super(element, as, parent);
    this.type = this.element.tagName;
    this.logic;
    this.item = Array.from(this.element.children)
      .filter((e) => e.tagName == "Item")
      .map((el) => {
        return new Item(el, this._as, this);
      });
    this.logic = Array.from(this.element.children)
      .filter((e) => e.tagName != "Item")
      .map((el) => {
        return new ConditionLogic(el, this._as, this);
      });
  }

  item: Item[];
  logic: ConditionLogic[] | undefined;
  type: string;
}

export class Item
  extends XMLBase<ConditionLogic>
  implements Omit<Definition.Item, "sourceValue">
{
  constructor(element: Element, as?: IFramework, parent?: ConditionLogic) {
    super(element, as, parent);
    this.sourceValue = this.element.textContent || undefined;
  }

  dataType?: Definition.DataType | undefined;
  sourceId?: string | undefined;
  sourceType!: Definition.ItemLocation;
  sourceName?: string | undefined;
  sourceDisplayName?: string | undefined;
  sourceInstanceId?: string | undefined;
  sourceSubFormId?: string | undefined;
  sourceValue: string | undefined; //

  public get sourceObject(): IControl | undefined {
    if ((this.sourceType = Definition.ItemLocation.Control)) {
      return this._as?.collections.viewInstanceControls.find(
        (c) => c.id == this.sourceId
      );
    }
  }
}



export class Action
  extends XMLBase<Handler>
{
  constructor(element: Element, as?: IFramework, parent?: Handler) {
    super(element, as, parent);
  }
    id!: string;
    definitionId!: string;
    type!:ActionType;    
    executionType!: Definition.ExecutionType;
    isReference!: Definition.Is;
    isInherited!: Definition.Is;
    itemState!: Definition.ItemState;
    instanceId!: string;
    location!:LocationEnum;
    method?: string | undefined;
    viewId?: string | undefined;
    designTemplate?: string | undefined;
    parameters?: Definition.ParameterElement[] 
    results?:  Definition.ParameterElement[] 
    objectId?: string | undefined;
    eventId?: string | undefined;
    messageLocation?: LocationEnum
    groupId?: string | undefined;
    ignoreInvisibleControls?: string | undefined;
    ignoreDisabledControls?: string | undefined;
    ignoreReadOnlyControls?: string | undefined;
    subformId?: string | undefined;
    heading?: string | undefined;
    formId?: string | undefined; 
    controlId?: string | undefined;
    order?: Definition.Order | undefined;
    filter?: Definition.ActionFilter | undefined;
     
}