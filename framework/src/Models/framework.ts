/*

    Alterspective Framework Module

    This modules is responsible for loading of the framework:
    1. Converting the K2 XML into json objects 
    2. Cleaning the json objects into a more user friendly representation 
    3. Adding event hooks to controls
    4. Adding control capabilities

*/

import { parseString as xmlToJS } from "xml2js";
import * as _ from "lodash";
import * as utils from "./Helpers/framework.utils";
import { Log, LogType, PerformanceSession } from "./framework.performance";
import { camelCase, reject } from "lodash";

import * as tt from "toastr";
import * as iframeResizer from "iframe-resizer";
import { IControllerDefinition } from "../interfaces/AGIControllerDefinition";
import { ControlType } from "../interfaces/enums";
import { ICollections } from "../interfaces/ICollections";
import { IControl } from "../interfaces/IControl";
import { ICustomControls } from "../interfaces/Icustom-controls";
import { IDependantControls } from "../interfaces/IDependantControls";
import { INotifications } from "../interfaces/INotifications";
import { IRule } from "../interfaces/IRule";
import { IUser } from "../interfaces/IUser";
import { IView } from "../interfaces/IView";
import { IViewInstance } from "../interfaces/IViewInstance";
import { Search } from "./search";
import { Control, ControlEvent, EmittedControlEvent } from "./control";
import { attachToControlEvents } from "./control-helpers";
import { CustomControls } from "./custom-controls";
import { Extensions } from "./extensions";
import { Form } from "./form";
import { Notifications } from "./notifications";
import { Rule, Rules } from "./rulev2";
import { Settings } from "./Settings";
import { User } from "./User";
import { ViewInstance } from "./viewInstances";
import { DeveloperMode } from "./developerMode";
import ToastrCss from "toastr/build/toastr.css";
import { IPerformanceSession } from "../interfaces/IPerformanceSession";
import { runTheFramework } from "./validateRun";
import { rejects } from "assert";
import { Name } from "../interfaces/AutoGenerated/so-ViewHash";
import { IExtensionConstructor, IForm, IFramework, IRegisteredExtensionModule } from "..";
import { ExtensionRegistrationOptions } from "./ExtensionRegistrationOptions";

//Add CSS Dependencies
//const ToastrCss = require("toastr/build/toastr.css")
const iFrameResizerContentsWindow = require("iframe-resizer/js/iframeResizer.contentWindow");
//const CodeEditorCss = require("monaco-editor/min/vs/editor/editor.main.css")

//constants
const thisFileName = "as-framework.ts";

export interface FrameworkInitializationOptions {
  scriptFilesUrl?: string;
  notificationsServerURL?: string;
  targetWindow?: Window;
}

export class Framework implements IFramework {
  supportingObjects!: SupportingObjects;
  form?: IForm;
  collections!: ICollections;
  search!: Search;
  window!: Window;
  initializePromise?: Promise<IFramework>;
  attachedEventsEnabled: boolean = true;
  extensions?: Extensions;
  customControls?: ICustomControls;
  toastr = tt;
  settings!: Settings;
  notifications!: INotifications;
  user!: IUser;
  iFrameResizer!: typeof iframeResizer.iframeResizer;
  toasrCss = ToastrCss;
  developerMode!: DeveloperMode;
  frameworkInitializeTime?: IPerformanceSession;

  public static asInitializePromise: Promise<IFramework>;

  public static async registerExtensionModule(
    moduleName: string,
    module: IExtensionConstructor,
    options?: ExtensionRegistrationOptions
  ): Promise<IRegisteredExtensionModule | undefined> {
    return Framework.initialize({
      notificationsServerURL: options?.notificationServerURL,
    }).then((as) => {
      return as.extensions?.registerModule(moduleName, module);
    });
  }
  
  //Static method to initialize the framework, used by any extension to run independently or with other extensions or where the base framework loaded already
  //A call to initialize will if its not initialized initialize and return a promise or if it is already initialized return the fulfilled promise
  public static initialize(
    options?: FrameworkInitializationOptions
  ): Promise<IFramework> {
    let targetWindow = options?.targetWindow || window; //sets default window if not specified
    if (!runTheFramework()) return Promise.reject("Framework Disabled!");

    if (!(window as any).alterspective)
      (window as any).alterspective = {
        PerformanceSession: PerformanceSession,
        Framework: Framework,
      };

    //looks first to see if the framework is in the default location "webpack settings"
    let windowFramework = (window as any).alterspective
      .Framework as typeof Framework;

    //If its not there, then set it to this location.
    //if(!windowFramework) (window as any).alterspective.Framework = Framework;

    if (!windowFramework.asInitializePromise) {
      targetWindow.as = new Framework(
        targetWindow,
        options?.scriptFilesUrl || "",
        options?.notificationsServerURL || ""
      );
      Framework.asInitializePromise = targetWindow.as.initialize();

      if (!(window as any).alterspective.Framework) {
        (window as any).alterspective.Framework = Framework;
      }
    }

    /**
     * Framework could start not using notifications and later a extension start that does
     * so here we allow the resetting of the notifications url
     */
    if (options?.notificationsServerURL) {
      if (
        options.notificationsServerURL != "" &&
        targetWindow.as.settings.notificationsServerURL !=
          options.notificationsServerURL
      ) {
        windowFramework.asInitializePromise.then((as) => {
          as.settings.notificationsServerURL = options.notificationsServerURL!;
        });
      }
    }

    return windowFramework.asInitializePromise;
  }

  constructor(
    windowInstance: Window,
    scriptFilesUrl: string,
    notificationsServerURL: string
  ) {
    if (!runTheFramework()) return;

    //todo test remove later

    let p = new PerformanceSession("AS.Constructor()");
    this.applyMaterialIcons();
    this.user = new User();
    this.settings = new Settings(scriptFilesUrl, notificationsServerURL);
    this.window = windowInstance;
    this.supportingObjects = new SupportingObjects();
    this.collections = new Collections();
    this.search = new Search(this);
    this.notifications = new Notifications(this);
    this.developerMode = new DeveloperMode(this);
    //this.initializePromise = this.initialize()
    windowInstance.as = this;

    this.iFrameResizer = iframeResizer.iframeResizer;
    //TODO not sure what i was doing with this, maybe before webpack?? This causes an issue so commented out
    //TODO Need o make sure iframe rezise is working after commenting out.
    //addScript(iFrameResizerContentsWindow, null, windowInstance.document)
  }

  //Starts the initialization of the framework using the setting passed into the constructor
  async initialize(): Promise<IFramework> {
    let p = new PerformanceSession("AS.Initialize()");

    return this.processK2SmartFormsXML(this.window).then(() => {
      let m = new PerformanceSession("AS.processK2SmartFormsXML");

      this.form = new Form(this);
      attachToControlEvents(this);
      this.collections.rules = new Rules(
        this.window.__runtimeEventsDefinition,
        this
      );
      this.applyEvalCommands();
      this.initializePostFrameworkLoadModules();

      this.attachPopupResizer();
      this.attachListener();

      this.checkForContentControlResizeRequest();
      this.developerMode.initialize();

      let y = ToastrCss.use({
        target: this.window.document.head,
        id: "toaster",
      });

      //   if(typeof (window as any).asFrameworkInitialized != 'undefined')
      //   {
      //     (window as any).asFrameworkInitialized()
      //   }

      m.finish();
      p.finish();
      this.frameworkInitializeTime = p;
      return this;
    });
  }

  inIframe() {
    try {
      return window.self !== window.top;
    } catch (e) {
      return true;
    }
  }

  private managePopupOpenedRunCounter = 0;
  private managePopupOpened() { //this is run only once.
    let targetNode = $(".popupManager")[0];
    let config = { attributes: false, childList: true, subtree: true };
    if (targetNode) {
      if (this.managePopupOpenedRunCounter == 0) {
        this.managePopupOpenedRunCounter++;
        const PopupObserver = new MutationObserver((entries) => {
          Log(`managePopupOpened `, {
            data: entries,
            logType: LogType.popupManager,
          });

          if ($(targetNode).children().length == 0) {
            $(targetNode).height("");
            $("body").height("");
          }
        });

        PopupObserver.observe(targetNode, config);
      }
    }
  }

  attachListener() {
    this.window.addEventListener(
      "message",
      (event) => {
        // Do we trust the sender of this message?  (might be
        // different from what we originally opened, for example).

        Log("Framework Event Received", {
          data: event,
          logType: LogType.windowMessaging,
        });

        if (event.data) {
          if (event.data == "sfrtFormReady") {
            this.managePopupOpened();
          }

          if (event.data.type) {
            if (event.data.type == "ASBodyHeightChanged") {
              if (event.source) {
                //this.window.postMessage(event); //bubble up
                let sourceDocument = (event.source as any).document;
                if (sourceDocument.defaultView) {
                  if (sourceDocument.defaultView.parent) {
                    Log('"TODO: Check - Is this in the same site:', {
                      data: sourceDocument.defaultView.parent,
                      logType: LogType.windowMessaging,
                    });
                    let parentDocument: any;
                    try {
                      parentDocument =
                        sourceDocument.defaultView.parent.document;
                    } catch (error) {
                      Log('"Parent is not accessible', {
                        data: sourceDocument.defaultView.parent,
                        logType: LogType.windowMessaging,
                        color: "red",
                      });
                    }

                    if (parentDocument) {
                      let popupManagerDocumentBody =
                        sourceDocument.defaultView.parent.document.body;
                      let popupManagerDiv =
                        parentDocument.getElementsByClassName(
                          "popupManager"
                        )[0];
                      let popupDialogDiv = $(
                        parentDocument.getElementsByClassName("popupManager")[0]
                      ).children()[1];

                      (this.window as any).popupDiv = popupManagerDiv;

                      let popupDocumentBodyHeight = $(parentDocument).height();
                      let diff =
                        event.data.height - (popupDocumentBodyHeight || 0);

                      if (diff > 0) {
                        $(popupManagerDiv).height(event.data.height + diff);
                        $(popupDialogDiv).height(event.data.height + diff);
                        $(popupManagerDocumentBody).height(
                          event.data.height + diff
                        );
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // event.source is popup
        // event.data is "hi there yourself!  the secret response is: rheeeeet!"
      },
      false
    );
  }

  //TODO: info on what this does
  attachPopupResizer() {
    const resizeObserver = new ResizeObserver((entries) => {
      entries[0].target.ownerDocument.defaultView?.postMessage({
        type: "ASBodyHeightChanged",
        height: entries[0].target.clientHeight,
      });
    });
    resizeObserver.observe(this.window.document.body);
  }

  //Ensures loading of javascript is optimised and cached
  async cachedScript(url: string, options: any): Promise<any> {
    options = $.extend(options || {}, {
      dataType: "script",
      cache: true,
      url: url,
    });
    return jQuery.ajax(options);
  }

  expressionToString(expression: string): string {
    let retValue = "";
    if(typeof expression!="string") return "";
    if(expression.length==0) return "";

    try {
      retValue = Function(`"use strict";return (${expression.toString()})`)();
    } catch (error) {
      console.warn(`Error executing script on control:`, error)
    }
    
    return retValue
  }

  escapeRegExp(str: string) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
  }

  applyEvalCommands() {
    let m = new PerformanceSession("AS.applyEvalCommands");
    let controlToEval = this.collections.viewInstanceControls.filter((ctr) =>
      ctr.name?.includes("~~")
    );

    controlToEval.forEach((ctr) => {
      let expToEval = ctr.name.split("~~")[1];
      if (expToEval) {
        ctr.value = eval(expToEval);
      }
    });

    //const regexString = /\{{([^\}}[]*)}}/gm;
    //const regexString = /\\~{{/gm;
 

  
    
    //Search for control that have {{}} nd translate the inside value into a eval fiunction
    try {
      this.collections.viewInstanceControls.filter((ctr)=>typeof ctr.value =="string")
        .filter((ctr) => ctr.value?.includes("~{{"))
        .forEach((ctr) => {
          console.log(`${ctr.name} has script - ${ctr.value}`)
         

        
        let script = extractScriptFromControlValue(ctr.value);
        let scriptExecutionValue = this.expressionToString(script);//Convert expression into string in closed context
        if(scriptExecutionValue!="") ctr.value  = scriptExecutionValue; 
         


          ctr.rules.OnChange?.addListener(`Script Change`,evt=>
          {
            let evtCtr = evt.detail.parent as IControl
            let script = extractScriptFromControlValue(evtCtr.value);
            let scriptExecutionValue = this.expressionToString(script);//Convert expression into string in closed context
            if(scriptExecutionValue!="") evtCtr.value  = scriptExecutionValue; 
          })

          // ctr.events.smartformEventChanged.addEvent((e:EmittedControlEvent)=>
          // {
          //   let script = extractScriptFromControlValue(controlValue);
          //   ctr.value  = this.expressionToString(script); 
          // })


          // let replacers = _.uniq(controlValue.match(regexString));
          // let processedReplacers = new Array<{ name: string; value: string }>();

          // replacers.forEach((r) => {
          //   let newValue = r;

          //   try {
          //     if (newValue.length > 3) {
          //       newValue = newValue.substring(2, newValue.length - 2);
          //       newValue = this.expressionToString(newValue); //Convert expression into string in closed context
          //     }
          //   } catch (ex: any) {
          //     newValue = `-- Error [${ex.toString()}] `;
          //   }
          //   processedReplacers.push({ name: r, value: newValue });
          //   controlValue = controlValue.replace(
          //     new RegExp(this.escapeRegExp(r), "g"),
          //     newValue
          //   );
          // });

          // ctr.value = controlValue;
          // let expToEval = ctr.value
          // if(expToEval)
          // {
          //     ctr.value = eval(expToEval)
          // }

          // ctr.rules.Changed?.addListener(evt=>{

          //     let value = (evt.detail.parent as IControl).value || "";
          //     (evt.detail.parent as IControl).value = eval(value)

          // })
        });
    } catch (error) {

        console.warn(error);
    }
    m.finish();

    //this.formName.value = this._as.form?.name
    //this.viewsOnForm.value = this._as.collections.views.map((v) => v.name).toString()
  }

  //Load modules that depend on the base framework having been loaded first
  initializePostFrameworkLoadModules() {
    this.customControls = new CustomControls(this);
    this.extensions = new Extensions(this);
  }

  //Converts the K2 XML Definitions into JSON Objects
  private async processK2SmartFormsXML(windowInstance: Window): Promise<void> {
    let p = new PerformanceSession("AS.validateFramework()");
    return new Promise(async (resolve, reject) => {
      let promiseArray = new Array<Promise<any>>();
      promiseArray.push(
        this.processXML(
          windowInstance.__runtimeControllersDefinition,
          "__runtimeControllersDefinition"
        )
      );
      promiseArray.push(
        this.processXML(
          windowInstance.__runtimeParametersDefinition,
          "__runtimeParametersDefinition"
        )
      );
      promiseArray.push(
        this.processXML(
          windowInstance.__runtimeSessionDetails,
          "__runtimeSessionDetails"
        )
      );
      // promiseArray.push(this.processXML(windowInstance.__runtimeEventsDefinition, "__runtimeEventsDefinition"))
      await Promise.all(promiseArray); //wait for all to complete and output performance
      p.finish();
      resolve();
    });
  }

  public convertXMLtoJSON(
    xml: string | Document | Element | Node | null | undefined
  ): any {
    let retValue: any;

    if (!utils.isDefined(xml)) {
      console.warn(`convertXMLtoJSON: xml is not defined`);
      return {};
    }
    let p = new PerformanceSession(`convertXMLtoJSON(${name})`);

    if (typeof xml != "string") {
      if ((xml as Element).outerHTML) {
        xml = (xml as Element).outerHTML;
      } else {
        xml = new XMLSerializer().serializeToString(xml!);
      }
    }

    let p1 = new PerformanceSession(`parseString(${name})`);
    xmlToJS(
      xml,
      {
        tagNameProcessors: [camelCase],
        attrNameProcessors: [camelCase],
        explicitArray: false,
        explicitRoot: true,
        mergeAttrs: true,
      },
      (err:any, r:any) => {
        if (err) {
          console.warn(err);
        }

        if (r) {
          retValue = r;
        } else {
          console.warn(`convertXMLtoJSON resulted in NULL`);
        }
        p1.finish();
      }
    );

    p.finish();
    return retValue;
  }

  //Processes a K2 XML into a object
  async processXML(xml: string, name: string) {
    if (!utils.isDefined(xml)) {
      console.warn(`processXML: xml is not defined`);
      return;
    }
    let p = new PerformanceSession(`processXML(${name})`);

    //Convert XML to Document

    (this.supportingObjects as any)[name + "_Document"] =
      utils.xmlToXMLDocument(xml);

    let p1 = new PerformanceSession(`parseString(${name})`);
    xmlToJS(
      xml,
      {
        tagNameProcessors: [camelCase],
        attrNameProcessors: [camelCase],
        explicitArray: false,
        explicitRoot: true,
        mergeAttrs: true,
      },
      (err : any, result : any) => {
        if (err) {
          console.warn(err);
        }

        if (result) {
          //tt.success(`${name} XML Processes`);
          (this.supportingObjects as any)[name + "_Object"] = result;
          // (this.supportingObjects as any)[name + '_JSON'] = JSON.stringify(result);
        } else {
          console.warn(`Processing XML ${name} resulted in NULL`);
        }
        p1.finish();
      }
    );

    p.finish();
  }

  //Helper Methods

  //View Instance Search Helpers
  getViewInstanceByName(name: string): IViewInstance {
    return genericSearchPropEqual(
      this.collections.viewInstances,
      "name",
      name
    )[0] as IViewInstance;
  }
  getViewInstancesByNameContains(name: string): IViewInstance[] {
    return genericSearchPropContains(
      this.collections.viewInstances,
      "name",
      name
    ) as IViewInstance[];
  }
  //View Search Helpers
  getViewByName(name: string): IView {
    return genericSearchPropEqual(this.collections.views, "name", name)[0];
  }
  getViewsByNameContains(name: string): IView[] {
    return genericSearchPropContains(this.collections.views, "name", name);
  }

  //Rule Search Helper
  getRulesByFriendlyName(name: string, viewInstanceName?: string): Rule[] {
    if (viewInstanceName) {
      let retValue =
        this.collections.rules?.rules?.filter(
          (r) =>
            r.ruleFriendlyName == name && r.parent?.name == viewInstanceName
        ) || [];
      if (retValue.length == 0) {
        retValue =
          this.collections.rules?.rules?.filter(
            (r) =>
              r.ruleFriendlyName == name &&
              (r.parent as IViewInstance).parent?.name == viewInstanceName
          ) || [];
      }
      return retValue;
    } else {
      return (
        this.collections.rules?.rules?.filter(
          (r) => r.ruleFriendlyName == name
        ) || []
      );
    }
    //return genericSearchPropEqual(this.collections.rules, "ruleFriendlyName", name, viewInstanceName)
  }

  //Control Search Helpers
  getControlsById(id: string, viewInstanceName?: string): IControl[] {
    return this.collections.viewInstanceControls.filter(
      (c) =>
        c.id === id &&
        (viewInstanceName ?? c.parent?.name === viewInstanceName, true)
    );
  }
  getControlsByName(name: string, viewInstanceName?: string) {
    return genericSearchPropEqual(
      this.collections.viewInstanceControls,
      "name",
      name,
      viewInstanceName
    );
  }
  getControlsByNameContains(name: string, viewInstanceName?: string) {
    return genericSearchPropContains(
      this.collections.viewInstanceControls,
      "name",
      name,
      viewInstanceName
    );
  }
  getControlsByType(type: string, viewInstanceName?: string) {
    return genericSearchPropEqual(
      this.collections.viewInstanceControls,
      "type",
      type,
      viewInstanceName
    );
  }
  getControlsByTypeContains(type: string, viewInstanceName?: string) {
    return genericSearchPropContains(
      this.collections.viewInstanceControls,
      "type",
      type,
      viewInstanceName
    );
  }

  /**
   *
   * @param configurationName - "controlName,viewName" | "controlName,viewInstanceName" | "controlName,current" -> for the current viewInstance with reference to a control
   * @param referenceViewInstance - when viewInstance == current the viewInstance to use
   * @returns IControl[]
   */
  getControlsByConfigurationName(
    configurationName: string,
    referenceViewInstance?: IViewInstance
  ): IControl[] {
    let { name, viewInstance } =
      this.getNameAndViewInstanceFromConfigurationString(
        configurationName,
        referenceViewInstance
      );
    return this.getControlsByName(name, viewInstance);
  }

  /**
   *
   * @param configurationName - "ruleName,viewName" | "ruleName,viewInstanceName" | "ruleName,current" -> for the current viewInstance with reference to a control
   * @param referenceViewInstance - when viewInstance == current the viewInstance to use
   * @returns IRule[]
   */
  getRulesByConfigurationName(
    configurationName: string,
    referenceViewInstance: IViewInstance
  ): Rule[] {
    let { name, viewInstance } =
      this.getNameAndViewInstanceFromConfigurationString(
        configurationName,
        referenceViewInstance
      );
    return referenceViewInstance._as.getRulesByFriendlyName(name, viewInstance);
  }

  /**
   *
   * @param configurationName - "name,viewName" | "name,viewInstanceName" | "name,current" -> for the current viewInstance with reference to a control
   * @param referenceViewInstance - when viewInstance == current the viewInstance to use
   * @returns {name, viewInstance}
   */
  getNameAndViewInstanceFromConfigurationString(
    configurationName: string,
    referenceViewInstance?: IViewInstance
  ) {
    let name = configurationName.split(",")[0];
    let viewInstance = configurationName.split(",")[1];
    if (viewInstance == "current") {
      if (referenceViewInstance) {
        viewInstance = referenceViewInstance.name!;
      } else {
        console.warn(
          `Error extracting current view instance from configuration value [${configurationName}] because referenceViewInstance parameter is undefined`
        );
        console.trace();
      }
    }
    return { name, viewInstance };
  }

  getControlFromElement(element: HTMLElement): IControl | undefined {
    let idArray = element.id.split("_");
    let viewId: string;
    let controlId: string;
    //some ids look like this {guid}_{guid}_Table
    //We need to clean this up to remove the trailing _Table that only occurs sometimes
    //If we have an ID and its array is 1, then we only have the controlId and need to look up the tree to find the viewId

    if (idArray.length < 2) {
      //TODO: might need to make this recursive, assuming the parent has the viewId below.
      if (!element.parentElement)
        throw "Cannot get view ID from control as there is no parent to get viewId";
      viewId = element.parentElement.id.split("_")[0] || "";
      controlId = idArray[0];
    } else {
      viewId = idArray[0];
      controlId = idArray[1];
    }

    return this.getControlsById(`${viewId}_${controlId}`)[0];
  }

  /**
   * Update View Instance Controls that are bound to an Objects Properties
   * @param viewInstance
   * @param dataObject
   */
  updateK2ControlsWithViewSmartObjectFields(
    viewInstance: IViewInstance,
    dataObject: any
  ) {
    for (const col in dataObject) {
      viewInstance.controls
        ?.filter((c) => (c.field?.name ? c.field.name == col : false))
        .forEach((c) => {
          if (dataObject[col]) c.value = dataObject[col];
          else c.value = "";
        });
    }
  }

  //Helper to validate a collection of controls are present on the page
  validateDependantControls(dependantControls: IDependantControls) {
    try {
      //check that all required controls are present
      for (const [key, value] of Object.entries(dependantControls)) {
        value.control = this.validateDependantControl(
          value.name,
          value.viewOrViewInstanceName
        );
      }
    } catch (err) {
      console.error(err);
      throw err;
    }
  }
  //Helper to validate a control is on the page
  validateDependantControl(
    name: string,
    viewOrViewInstanceName: string
  ): IControl {
    let retControl: Control;

    let dependantViewInstance;
    if (viewOrViewInstanceName) {
      dependantViewInstance = this.collections.views.find(
        (v) => v.viewName == viewOrViewInstanceName
      )?.viewInstances[0] as ViewInstance;
      if (!dependantViewInstance)
        dependantViewInstance = this.collections.viewInstances.find(
          (v) => v.name == viewOrViewInstanceName
        ) as ViewInstance;
    }

    if (!dependantViewInstance)
      throw `A dependant view or viewInstance [${viewOrViewInstanceName}] was not found `;

    retControl = this.getControlsByName(name, dependantViewInstance.name)[0];
    if (!retControl) {
      console.warn(
        `aA dependant control [${name}] was not found on view/viewInstance [${viewOrViewInstanceName}]`
      );
      //fordev
      //debugger;
      console.warn(
        `View/viewInstance [${viewOrViewInstanceName}] has the following controls:`
      );
      _.sortBy(dependantViewInstance.controls, (c) => c.containerType).forEach(
        (c) => {
          console.log(
            `%c ${c.type} - %c ${c.name}`,
            "background: #222; color: green",
            "background: #222; color:  #bada55"
          );
        }
      );
      throw `A dependant control [${name}] was not found on view/viewInstance [${viewOrViewInstanceName}]`;
    }

    return retControl;
  }

  //TODO: this adds materail icons to the page linking to google, this must change to use webpack instead so we can decide to use links or package SCSS locally
  //RISK: potential issue calling external links in closed secure env..
  private applyMaterialIcons() {
    $("head").append(
      $('<link rel="stylesheet" type="text/css" />').attr(
        "href",
        "https://fonts.googleapis.com/icon?family=Material+Icons"
      )[0]
    );
  }

  //Adds monitoring to all content controls on the page to initialise resize on changes
  //TODO: move this to a specific lib?
  checkForContentControlResizeRequest() {
    this.collections.viewInstanceControls
      .filter((c) => c.type == ControlType.Content)
      .forEach((control) => {
        let contentsControl = control.asContentControl();
        contentsControl.events.smartformEventChanged.addEvent(() => {
          contentsControl!.autoResize = true;
        });
        if ($("iframe", contentsControl.getHTMLElement())[0]) {
          //check if we already have a iframe loaded
          contentsControl.autoResize = true;
        }
      });
  }
}

//Container of flatterned k2 XML Definitions that have been converted to objects
class Collections implements ICollections {
  viewInstanceControls = new Array<Control>();
  viewInstances = new Array<IViewInstance>();
  views = new Array<IView>();
}

function extractScriptFromControlValue(controlValue?: string) {
  
  if(typeof controlValue!="string") return "";
  if(controlValue.indexOf("~{{")==-1) return "";
  
    let scriptStartPosition = controlValue.indexOf("~{{") + 3;
    let script = controlValue.substring(scriptStartPosition);
    return script;
  

}

//Helper - search for a property of a object =, if view  view instance name passed in then scope to that level
export function genericSearchPropEqual(
  array: Array<any>,
  prop: string,
  value: string,
  viewInstanceName?: string
): any[] {
  return array.filter((c: any) => {
    if (c[prop]) {
      if (viewInstanceName)
        return c[prop] == value && c.parent.name == viewInstanceName;
      else return c[prop] == value;
    }
  });
}

//Helper - search for a property of a object contains, if view  view instance name passed in then scope to that level
export function genericSearchPropContains(
  array: Array<any>,
  prop: string,
  value: string,
  viewInstanceName?: string
): any[] {
  return array.filter((c: any) => {
    if (c[prop]) {
      if (viewInstanceName)
        return c[prop].contains(value) && c.parent.name == viewInstanceName;
      else return c[prop].contains(value);
    }
  });
}

//Container for the k2 xml that has been converted to objects
class SupportingObjects {
  __runtimeControllersDefinition_Object?: IControllerDefinition.ControllerDefinition;
  __runtimeEventsDefinition_Object?: any;
  __runtimeEventsDefinition_Document?: Document;
  __runtimeSessionDetails_Document?: Document;
  __runtimeSessionDetails_Object?: any;
  __runtimeParametersDefinition_Document?: Document;
  //  __runtimeParametersDefinition_Object?: ParameterDefinitions.ParameterDefinitions
  constructor() {}
}
