import { Framework } from "./framework";
import { IFramework } from "../interfaces/IFramework";
import { Control } from "./control";
import { IControl } from "../interfaces/IControl";
import { Log, LogType, PerformanceSession } from "./framework.performance";
import {
  EventTimingOption,
  ViewInstanceEventTypeOption,
} from "../interfaces/IEvents";
import { Action, ActionType, LocationEnum, Rule } from "./rulev2";
import { ControlRuleKeys } from "../interfaces/IControlRules";
import { ItemState, SourceType } from "../interfaces/AutoGenerated/so-rulesv2";
import { JP } from "./Helpers/framework.utils";
import { ViewInstance } from "./viewInstances";

//Used to turn on and off logging
let performanceMeasureEnabled = false;
let performanceLogEnabled = false;

export function attachToControlEvents(as: Framework) {
  //debugger;
  //For reloading

  //Reset to origional handleEvent
  if (typeof as.window.originalHandleEvent != "undefined") {
    as.window.handleEvent = as.window.originalHandleEvent;
    as.window.originalHandleEvent = undefined;
  }

  //Reset to original Execute Control Function
  if (typeof as.window.originalExecuteControlFunction != "undefined") {
    as.window.executeControlFunction = as.window.originalExecuteControlFunction;
    as.window.originalExecuteControlFunction = undefined;
  }

  //If we have not set  original HandleEvent then overload it with extended functions
  if (typeof as.window.originalHandleEvent === "undefined") {
    as.window.originalHandleEvent = as.window.handleEvent; //Save the original to call from within the extended
    //Now we overwrite the handel even with the extended

    as.window.handleEvent = function (
      sourceId: string,
      sourceType: string,
      eventName: string,
      r: any,
      u: any,
      f: any,
      e: any,
      o: any,
      s: any,
      h: any,
      c: any,
      l: any
    ) {
      let p = new PerformanceSession(
        "as.window.originalHandleEvent",
        LogType.performanceCheck
      );
      let control: IControl | undefined;

      if (sourceType == "Control") {
        control = as.collections?.viewInstanceControls?.find(
          (c) => c.id == sourceId
        );
        p.log("Is a control with name:", control?.name);
        p.log("control value: ", control?.value)
        p.log("Dispatching to Control(before) Listeners inside promise")
        //TODO- add control dispatch rule?.dispatch(ExecutedRuleEventTypes.before)
      }

      //Execute Control Handler Function - Different to events
      //Get all registered control that are set to get events before the control is updated
      //TODO - temp
      if (sourceType == "Control" && control !== null) {
        getControlHandlers()
          .filter((handler) => {
            return (
              control?.id === handler.control.id &&
              handler.event === eventName &&
              handler.when === "before"
            );
          })
          .forEach(function (item) {
            p.log(
              `executing control [${item.control.name}] event hander :`,
              item
            );
            item.handler(getControlInfo(sourceId, as), null, null); //Executing the item handler function
          });
      }

      //Call the original event
      p.log(
        "//------------------- Calling Original Function ----------------//"
      );
      var returnedPromise = as.window.originalHandleEvent(
        sourceId,
        sourceType,
        eventName,
        r,
        u,
        f,
        e,
        o,
        s,
        h,
        c,
        l
      );

      manageEvent(
        as,     
        sourceId,
        sourceType,
        eventName,
        r,
        u,
        f,
        e,
        o,
        s,
        h,
        c,
        l
      );
      
      p.log(
        "//------------------- After Calling Original Function ----------------//"
      );

      p.finish();

      if (returnedPromise != null) {
        returnedPromise.then(function (...args: any) {
         

          //TODO- temp
          if (control) {
            //Get all registered control that are set to get events after the control is updated
            getControlHandlers()
              .filter(function (handler) {
                return (
                  control?.id === handler.control.id &&
                  handler.event === eventName &&
                  handler.when === "after"
                );
              })
              .forEach(function (item) {
                Log(
                  `old method - executing control [${item.control.name}] event hander :`,
                  { data: item, logType: LogType.events }
                );
                item.handler(getControlInfo(sourceId, as), null, null); //Execute after rule
              });
          }
        });
      }
      else
      {       
      }

      return returnedPromise;
    };
  }

  //if(false)
  if (typeof as.window.originalExecuteControlFunction === "undefined") {
    as.window.originalExecuteControlFunction = as.window.executeControlFunction;
    as.window.executeControlFunction = function (
      controlInfo: any,
      eventName: string,
      valueInfo: any
    ) {
      let p = new PerformanceSession(
        "as.window.executeControlFunction",
        LogType.events
      );
      p.log("TCL: attachToControlEvents -> controlInfo", controlInfo);
      p.log("TCL: attachToControlEvents -> eventName", eventName);
      p.log("TCL: attachToControlEvents -> valueInfo", valueInfo);
      p.log("TCL: attachToControlEvents -> value", value);
      p.log("TCL: attachToControlEvents -> arguments", arguments);
      p.log("---------------------------------------");

      p.log(
        "----------------Before originalExecuteControlFunction -----------------------"
      );

      if (as.attachedEventsEnabled == true) {
        if(controlInfo.tagName != "Control")
        {
          console.warn("!!!! Control Info is not a Contol type !!!")
        }
        let control = as.getControlsById(valueInfo.CurrentControlId)[0];
        if (control) {
          control.dispatchPropertyEvent(eventName,EventTimingOption.before,{ when:EventTimingOption.before, control:control,  eventName:eventName, property: valueInfo.property || "unknown", value:valueInfo.Value})
        }

        //Get all controls registered to fire on the before value changed
        getControlHandlers()
          .filter(function (handler) {
            var name;
            if (typeof controlInfo.getAttribute != "undefined") {
              name = controlInfo.getAttribute("Name");
            } else {
              name = controlInfo.Name;
            }
            return (
              handler.control.name === name &&
              handler.event === eventName &&
              handler.when === "before"
            );
          })
          .forEach(function (item) {
            p.log(
              `executing control [${item.control.name}] event hander :`,
              item
            );
            item.handler(controlInfo, valueInfo, null); //Fire the function
          });
      }

      p.log(
        "----------------Calling originalExecuteControlFunction -----------------------"
      );
      var value = as.window.originalExecuteControlFunction(
        controlInfo,
        eventName,
        valueInfo
      );

      p.log(
        "----------------After originalExecuteControlFunction -----------------------"
      );
      p.log("returned value:", value);

      if (as.attachedEventsEnabled == true) {
        let control = as.getControlsById(valueInfo.CurrentControlId)[0];
        if (control) {
          control.dispatchPropertyEvent(eventName,EventTimingOption.after,{ when:EventTimingOption.after, control:control,  eventName:eventName, property: valueInfo.property || "unknown", value:valueInfo.Value})
        }

        //Firing Functions
        //Get all registers controls that want to receive events after value changed
        getControlHandlers()
          .filter(function (handler) {
            var name;
            if (typeof controlInfo.getAttribute != "undefined") {
              name = controlInfo.getAttribute("Name");
            } else {
              name = controlInfo.Name;
            }

            return (
              handler.control.name === name &&
              handler.event === eventName &&
              handler.when === "after"
            );
          })
          .forEach(function (item) {
            p.log(
              `executing control [${item.control.name}] event hander :`,
              item
            );
            item.handler(controlInfo, valueInfo, value); //Fire the function
          });
      }
      p.finish();
      return value;
    };
  }
}
//TODO- Temp
// function emitControlChangedEvent(
//   eventName: string,
//   valueInfo: any,
//   control: IControl,
//   oldValue: any,
//   when: "before" | "after"
// ) {
//   if (eventName.toLocaleLowerCase() == "setproperty") {
//     let proChangedEvent: ChangedEvent = {
//       control: control,
//       type: ChangedEventTypes.property,
//       property: valueInfo.property,
//       newValue: valueInfo.Value,
//       oldValue: oldValue,
//       when: when,
//     };
//     control?.dispatch(ChangedEventTypes.property, proChangedEvent);
//   } else if (eventName.toLocaleLowerCase() == "setvalue") {
//     let proChangedEvent: ChangedEvent = {
//       control: control,
//       type: ChangedEventTypes.value,
//       newValue: valueInfo.Value,
//       oldValue: oldValue,
//       when: when,
//     };
//     control?.dispatch(ChangedEventTypes.value, proChangedEvent);
//   }
// }

function getControlInfo(controlId: string, as: IFramework) {
  return new as.window.PopulateObject(null, null, controlId);
}

interface ControlHandler {
  control: Control;
  controlId?: string;
  event: string;
  handler: Function;
  when: string;
}

let controlHandlers = new Array<ControlHandler>();
function getControlHandlers(): ControlHandler[] {
  return controlHandlers;
}

export function attachHandler(
  control: Control,
  event: string,
  when: string,
  handler: Function
) {
  controlHandlers.push({
    control: control,
    controlId: control.id,
    event: event,
    handler: handler,
    when: when,
  });
}

export function executeControl(
  control: Control,
  method: string,
  as: IFramework,
  optionalValue?: any,
  optionalPropertyName?: any
) {
  var executionResult = null; // the result of executing the control

  //use K2 function to populate the function parameter
  var functionInputConfig = new as.window.PopulateObject(
    null,
    optionalValue,
    control.id
  );

  //if there are any optionals apply them into the function input parameter
  if (optionalPropertyName != null)
    functionInputConfig.property = optionalPropertyName;

  try {
    //Build the controlHash - K2 functions are all stored in a array
    var controlHashName = (control.id + "_" + method) as any;
    //Get the function to execute
    let functionToExecute =
      as.window.executeControlFunctionHash[controlHashName];
    //in cases with autogenerated forms the function could be empty, if se we need to set it manually
    if (typeof functionToExecute == "undefined") {
      // var u = $.grep<any>(control.properties!, function (x) {
      //   return x.name === method;
      // })[0].value;

      //get The Control Property execute value
      let propertyValue = control.properties!.find(
        (c) => c.name === method
      )?.value;

      if (propertyValue != null) {
        //now get the function and set it in the control hash collection for next time
        functionToExecute = as.window.evalFunction(propertyValue);
        as.window.executeControlFunctionHash[controlHashName] =
          functionToExecute;
      } else as.window.executeControlFunctionHash[controlHashName] = -1;
    }

    if (typeof functionToExecute == "function") {
      executionResult = functionToExecute(functionInputConfig);
    } else {
      // what to do if not a function
      // console.warn(
      //   `${control.name} of ${control.parent.name} - ${method} is not a function `
      // );
      //functionToExecute === -1 && (q.functionExists = !1)
    }
  } catch (err) {
    console.warn(
      `${control.name} of ${control.parent.name} - ${method} caused an error `
    );
    console.warn(err);
  }
  return executionResult;
}

//   var ht = {
//     methodExecuted: q,
//     handlers: v,
//     SourceID: n,
//     SourceType: t,
//     SubformID: a ? a.getAttribute("SubformID") : null,
//     InstanceID: a ? a.getAttribute("InstanceID") : null,
//     TransferredID: a ? a.getAttribute("TransferredID") : null,
//     IsAsync: r,
//     isInit: f,
//     parentBehaviour: e,
//     popup: s,
//     closeOptions: h,
//     closeEvent: o,
//     deferred: g,
//     singleSpinner: et,
//     windowToUse: window.self
// }

function manageEvent(
  as: IFramework,
  sourceId: string,
  sourceType: string,
  methodExecuted: string,
  isAsync: string,
  viewInstanceId: string,
  isInit: string,
  parentBehavior: string,
  closeEvent: boolean,
  popup: string,
  closeOptions: string,
  c: string,
  l: string
) {
  let p = new PerformanceSession(
    `Finding rule for ${sourceId} ${sourceType} ${methodExecuted}`
  );
  let foundRules: Array<Rule> = [];

  if (as.collections.rules?.rules) {
    //first search for registered events
    foundRules = as.collections.rules.rules.filter(
      (r) => r.sourceId == sourceId && r.name == methodExecuted
    );

    //Fire emitters for found rules
    if (foundRules.length > 0) {
      foundRules.forEach((r) => {
        r.dispatch();
      });
    }

    if (sourceType != SourceType.Control) {
      //search actions

      let foundAction: Action | undefined;
      // let foundRule: Rule | undefined;
      let continueSearching = true;

      // let pp = new PerformanceSession("for each loop",LogType.performanceCheck,true);
      // //search through all actions to find a match to the method, then set the action and rule found
      // //note the rule found might not be the rule that fired as it might not be bound but it gives us the info
      // //to determine the type of rule
      // //Note: this search ended up taking +- 2.5ms vs using jsonPath which took 30ms
      // as.collections.rules.rules.every((r) => {
      //   r.handlers.every((h) => {
      //     h.actions.every((a) => {
      //       if (a.method == methodExecuted && a.location == sourceType) {
      //                      // foundRule = a.parent?.parent;
      //         foundAction = a;
      //         continueSearching = false;
      //         return false;
      //       }
      //       return continueSearching;
      //     });
      //     return continueSearching;
      //   });
      //   return continueSearching;
      // });
      // //if (foundAction) Log("Found", { color: "pink", data: foundAction });
      // pp.finish();

      //For loop executed 10x faster than foreach!!
      let pp = new PerformanceSession("for loop",LogType.performanceCheck);
      
      let viewInstanceRulesToSearch = as.collections.rules.rules.filter(r=>r.instanceId==viewInstanceId)
      
      for (let rindex = 0; rindex < viewInstanceRulesToSearch.length; rindex++) {
        const r = viewInstanceRulesToSearch[rindex];

        for (let hindex = 0; hindex < r.handlers.length; hindex++) {
          const h = r.handlers[hindex];
          
          for (let aindex = 0; aindex < h.actions.length; aindex++) {
            const a = h.actions[aindex];
            
            if (a.method == methodExecuted && a.location == sourceType) {
              // foundRule = a.parent?.parent;
            foundAction = a;
            continueSearching = false;
            break;
            }
          }
          if(!continueSearching) break
        }
        if(!continueSearching) break
      }
      pp.finish();




      if (foundAction) {
        //if we have any then we have a view method event

        let viewInstanceEventTypeOption: ViewInstanceEventTypeOption;

        switch (foundAction.itemState) {
          case ItemState.Added:
            viewInstanceEventTypeOption = ViewInstanceEventTypeOption.create;
            break;
          case ItemState.All:
            viewInstanceEventTypeOption = ViewInstanceEventTypeOption.list;
            break;
          case ItemState.Changed:
            viewInstanceEventTypeOption = ViewInstanceEventTypeOption.update;
            break;
          case ItemState.Removed:
            viewInstanceEventTypeOption = ViewInstanceEventTypeOption.delete;
            break;
          default:
            viewInstanceEventTypeOption = ViewInstanceEventTypeOption.unknown;
            break;
        }

        // Log(
        //   `----------- Found in Actions - Fire [${foundAction.location}] Event [${viewInstanceEventTypeOption}] ---------------`,
        //   { color: "red" }
        // );

        switch (foundAction.location) {
          case LocationEnum.Control:
            break;
          case LocationEnum.ObjectProperty:
            break;
          case LocationEnum.Result:
            break;
          case LocationEnum.Value:
            break;
          case LocationEnum.ViewField:
            break;
          case LocationEnum.ViewParameter:
            break;
          case LocationEnum.ItemState:
            break;
          case LocationEnum.SystemVariable:
            break;
          case LocationEnum.Form:
            break;
          case LocationEnum.Rule:
            break;
          case LocationEnum.SourceTypeView:
            break;
          case LocationEnum.View:           
            let viewInstance = as.collections.viewInstances.find(vi=>vi.instanceId==foundAction?.instanceId)
            if (viewInstance) {
              viewInstance.dispatch(viewInstanceEventTypeOption);
            } else {
              debugger;
            }
            break;
          default:
            break;
        }
      }
    }
  }
  p.finish();
  return foundRules;
}
